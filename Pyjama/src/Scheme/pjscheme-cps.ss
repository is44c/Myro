(define *ignore-functions*
  '(
1st
REP-handler
REP-k
and-transformer
anything?
app-exp
application?
apply-proc
apply-state
assign-exp
assignment?
begin-exp
begin?
binding-value
binding-variable
catch-exps
catch-var
catch?
char-boolean?
char-delimiter?
char-initial?
char-sign?
char-special-subsequent?
char-subsequent?
chars-to-scan
closure
cond-transformer
constant?
data-structure-procedure?
data-structure-procedure?
define-exp
define-syntax-exp
define-syntax?
define?
empty-frame?
extend
finally-exps
finally?
first
first-binding
first-frame
get-parsed-sexps
get-variables
group
head
if-else?
if-exp
if-then?
init-cont
init-cont2
init-handler
lambda-exp
lambda?
last
let*-transformer
let-transformer
letrec-transformer
lit-exp
literal?
load-stack
macro-env
make-binding
make-cont
make-cont2
make-empty-environment
make-frame
make-handler
make-initial-environment
make-macro-env
make-proc
make-sub
make-toplevel-env
mit-define-transformer
mit-style?
module?
mu-closure
mu-lambda-exp
or-transformer
parse-string
pattern-variable?
pattern?
print-parsed-sexps
quasiquote?
quote?
raise-exp
raise?
range
read-content
read-eval-print
read-file
read-next-sexp
read-string
record-case-transformer
remaining
reserved-keyword?
rest-of
rest-of-bindings
rest-of-frames
safe-print
scan-file
scan-string
search-env
search-frame
set-binding-value!
set-first-frame!
start
string->decimal
string->integer
string->number
string->rational
syntactic-sugar?
tagged-list
token-type?
toplevel-env
true?
try-body
try-catch-exp
try-catch-finally-exp
try-catch-finally-handler
try-catch-handler
try-finally-exp
try-finally-handler
try?
unquote-splicing?
unquote?
var-exp
    ))

(define *function-signatures*
  '(
    ))


