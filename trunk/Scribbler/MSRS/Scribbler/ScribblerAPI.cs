//------------------------------------------------------------------------------
// ScribblerState.cs
//
//     This code was generated by the DssNewService tool.
//
//      Ben Axelrod 08/28/2006
//
//------------------------------------------------------------------------------
using Microsoft.Ccr.Core;
using Microsoft.Dss.ServiceModel.Dssp;
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using W3C.Soap;


namespace IPRE.ScribblerBase
{
    internal class ScribblerHelper
    {
        /// <summary>
        /// enumeration of Scribbler API commands
        /// </summary>
        public enum Commands
        {
            GET_INPUT = 1,
            GET_OPEN_LEFT = 2,
            GET_OPEN_RIGHT = 3,
            GET_STALL = 4,
            GET_LIGHT_LEFT = 5,
            GET_LIGHT_CENTER = 6,
            GET_LIGHT_RIGHT = 7,
            GET_LINE_RIGHT = 8,
            GET_LINE_LEFT = 9,
            GET_ALL_BINARY = 10,

            GET_OPEN_LEFT_RESPONSE = 11,
            GET_OPEN_RIGHT_RESPONSE = 12,
            GET_STALL_RESPONSE = 13,
            GET_LIGHT_LEFT_RESPONSE = 14,
            GET_LIGHT_CENTER_RESPONSE = 15,
            GET_LIGHT_RIGHT_RESPONSE = 16,
            GET_LINE_RIGHT_RESPONSE = 17,
            GET_LINE_LEFT_RESPONSE = 18,
            GET_ALL_BINARY_RESPONSE = 19,

            SET_MOTORS_OFF = 20,
            SET_MOTORS = 21, // 21 RightMotorSpeed LeftMotorSpeed    (units: 1 = full speed backwards, 100 = stopped, 200 = full speed forward)
            SET_LED_LEFT_ON = 22,
            SET_LED_LEFT_OFF = 23,
            SET_LED_CENTER_ON = 24,
            SET_LED_CENTER_OFF = 25,
            SET_LED_RIGHT_ON = 26,
            SET_LED_RIGHT_OFF = 27,
            SET_SPEAKER = 28, // 28 duration frequency1 [frequency2]   (duration units is 10x ms, freqency x 6 + 250 = Hz 250->2000) set freq2 to 0 for none
        }

        /// <summary>
        /// tests whether incoming message from scribbler is a sensor state update, or just an echo
        /// </summary>
        public static bool IsSensorResponse(byte test)
        {
            switch ((Commands)test)
            {
                case Commands.GET_OPEN_LEFT_RESPONSE:
                case Commands.GET_OPEN_RIGHT_RESPONSE:
                case Commands.GET_STALL_RESPONSE:
                case Commands.GET_LIGHT_LEFT_RESPONSE:
                case Commands.GET_LIGHT_CENTER_RESPONSE:
                case Commands.GET_LIGHT_RIGHT_RESPONSE:
                case Commands.GET_LINE_RIGHT_RESPONSE:
                case Commands.GET_LINE_LEFT_RESPONSE:
                case Commands.GET_ALL_BINARY_RESPONSE:
                    return true;
                    break;
                default:
                    return false;
                    break;
            }
        }

        /// <summary>
        /// returns the sensor type in form of string
        /// </summary>
        public static string SensorType(byte test)
        {
            switch ((Commands)test)
            {
                case Commands.GET_OPEN_LEFT_RESPONSE:
                    return "IRLeft";
                    break;
                case Commands.GET_OPEN_RIGHT_RESPONSE:
                    return "IRRight";
                    break;
                case Commands.GET_STALL_RESPONSE:
                    return "Stall";
                    break;
                case Commands.GET_LIGHT_LEFT_RESPONSE:
                    return "LightLeft";
                    break;
                case Commands.GET_LIGHT_CENTER_RESPONSE:
                    return "LightCenter";
                    break;
                case Commands.GET_LIGHT_RIGHT_RESPONSE:
                    return "LightRight";
                    break;
                case Commands.GET_LINE_RIGHT_RESPONSE:
                    return "LineRight";
                    break;
                case Commands.GET_LINE_LEFT_RESPONSE:
                    return "LineLeft";
                    break;
                case Commands.GET_ALL_BINARY_RESPONSE:
                    return "AllBinary";
                    break;
                default:
                    return "None";
                    break;
            }
        }

        /// <summary>
        /// takes in the status byte from the 'AllBinary' command and 
        /// demomposes it into sensor data.
        /// <remarks>Format: 0b000 IRLeft IRRight Stall LineLeft LineRight</remarks>
        /// </summary>
        public struct AllBinaryDecomp
        {
            public bool IRLeft;
            public bool IRRight;
            public bool Stall;
            public bool LineLeft;
            public bool LineRight;

            public AllBinaryDecomp(int b)
            {
                this.IRLeft = (b & 0x10) > 0;
                this.IRRight = (b & 0x08) > 0;
                this.Stall = (b & 0x04) > 0;
                this.LineLeft = (b & 0x02) > 0;
                this.LineRight = (b & 0x01) > 0;
            }
        }

    }
}
