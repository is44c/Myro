// Copyright (c) Microsoft Corporation.  All rights reserved.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     DSS Runtime Version: 2.0.730.3
//     CLR Runtime Version: 2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using submgr = Microsoft.Dss.Services.SubscriptionManager;
using Microsoft.Dss.Core.DsspHttp;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using System.Linq;
using System.Threading;
using W3C.Soap;
using Myro.Utilities;
using partnerList = Microsoft.Dss.Services.PartnerListManager;
using partnerListS = Microsoft.Dss.Schemas.PartnerListManager;
using analog = Microsoft.Robotics.Services.AnalogSensor.Proxy;
using analogArray = Microsoft.Robotics.Services.AnalogSensorArray.Proxy;
using contact = Microsoft.Robotics.Services.ContactSensor.Proxy;

namespace Myro.Services.Generic.Vector
{
    /// <summary>
    /// This is a base class for building services that can represent their
    /// data as a Vector, or a set of key-value pairs.  This class makes
    /// building new services easy, since it takes care of all get and set
    /// requests (get/set by index, by key, or all elements at once), and also
    /// handles subscribers.
    /// 
    /// To build a sensor service, you have to implement some way of updating
    /// the state.  This can either be with a subscription to another service,
    /// a periodic timer, or with a callback (by overriding GetCallback, which
    /// will be called whenever any part of the state is requested).
    /// 
    /// To build an actuator service, your options are basically the same.  If
    /// another service subscribes to this one, you don't have to do anything.
    /// Otherwise, you can add a callback (by overriding SetCallback), or you
    /// can read the state periodically.
    /// 
    /// When overriding GetCallback() and SetCallback(), you can throw an
    /// exception to indicate an error.  If you do, subscribers will not be
    /// notified, and the Vector class will encapsulate the exception with a
    /// Fault (using RSUtils.FaultOfException()), which you can either
    /// retrieve on the other end using RSUtils.ExceptionOfFault(), or if you
    /// use RSUtils.SyncReceive<>(), this method will automatically retrieve
    /// and re-throw the exception.  NOTE:  If a Fault is generated by the DSS
    /// system, and does not encapsulate an exception,
    /// RSUtils.ExceptionOfFault() will instead throw a FaultReceivedException,
    /// which encapsulates the Fault.
    /// 
    /// You do not need to actually modify the state in SetCallback(), it will
    /// already have been modified by the Vector base class.  Likewise, you do
    /// not need to throw exceptions from the above callbacks for index
    /// out-of-bounds, invalid key, etc, these will be handled automatically.
    /// The callbacks simply allow you to communicate with the hardware or with
    /// another service.
    /// 
    /// Although the state properties are public (this is necessary for
    /// serialization), DO NOT modify them directly, because there is an
    /// internal cache of key-index mappings, which must be rebuilt if a key
    /// changes, or if the number of keys or values changes.
    /// 
    /// The key and value lists do not have to have the same lengths, if there
    /// are more values than keys, the end values will only be accessible by
    /// index, and if there are more keys than values, those keys will simply
    /// by unused (and throw UnknownKeyExceptions).  This flexibility implies
    /// that you do not even have to use the keys at all if clients will
    /// always access elements by index.
    /// 
    /// Also, auto-subscription is a way of hooking this service up to 
    /// automatically get its state from one or more generic contract services,
    /// which must be either Analog, AnalogArray, or Contact.  You set up auto-
    /// subscription using partners whose names start with "auto-".  See the
    /// developers manual for instructions on how to do this (this is how you
    /// make Myro work with pre-made generic robot services).
    /// 
    /// If all else fails, see the Myro Developer's Manual.
    /// </summary>
    //[DisplayName("Vector")]
    //[Description("A Generic Vector Service")]
    //[Contract(Contract.Identifier)]
    public abstract class VectorServiceBase : DsspServiceBase
    {
        #region Member variables

        /// <summary>
        /// _state
        /// </summary>
        protected VectorState _state = null;

        [InitialStatePartner(Optional = true)]
        protected VectorState initialState = new VectorState();

        // NOTE: These are only used to get auto partners to show up in the
        // manifest editor.  Any partner starting with "Auto_" will be used,
        // so you can specify more in a manifest if there are not enough
        // already defined.
        [Partner("Auto_Analog_1", Contract = analog.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UsePartnerListEntry, Optional = true)]
        protected analog.AnalogSensorOperations autoPartner1 = new analog.AnalogSensorOperations();
        [Partner("Auto_AnalogArray_1", Contract = analogArray.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UsePartnerListEntry, Optional = true)]
        protected analogArray.AnalogSensorOperations autoPartner2 = new analogArray.AnalogSensorOperations();
        [Partner("Auto_Contact_1", Contract = contact.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UsePartnerListEntry, Optional = true)]
        protected contact.ContactSensorArrayOperations autoPartner3 = new contact.ContactSensorArrayOperations();
        [Partner("Auto_Analog_2", Contract = analog.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UsePartnerListEntry, Optional = true)]
        protected analog.AnalogSensorOperations autoPartner4 = new analog.AnalogSensorOperations();
        [Partner("Auto_AnalogArray_2", Contract = analogArray.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UsePartnerListEntry, Optional = true)]
        protected analogArray.AnalogSensorOperations autoPartner5 = new analogArray.AnalogSensorOperations();
        [Partner("Auto_Contact_2", Contract = contact.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UsePartnerListEntry, Optional = true)]
        protected contact.ContactSensorArrayOperations autoPartner6 = new contact.ContactSensorArrayOperations();

        private List<AutoDefinition> autoDefs;

        /// <summary>
        /// _main Port
        /// </summary>
        //[ServicePort("/vector", AllowMultipleInstances = false)]
        //private VectorOperations _operationsPortInternal = new VectorOperations();
        //protected VectorOperations OperationsPort { get { return _operationsPort; } private set { _operationsPort = value; } }
        protected abstract VectorOperations OperationsPort { get; }

        /// <summary>
        /// Subscription manager port
        /// </summary>
        [Partner("SubMgr",
            Contract = submgr.Contract.Identifier,
            CreationPolicy = PartnerCreationPolicy.CreateAlways,
            Optional = false)]
        private submgr.SubscriptionManagerPort _subMgrPort = new submgr.SubscriptionManagerPort();

        #endregion

        #region Initialization

        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public VectorServiceBase(DsspServiceCreationPort creationPort)
            : base(creationPort)
        {
        }

        /// <summary>
        /// Service Start
        /// </summary>
        protected override void Start()
        {
            if (_state == null && initialState != null)
            {
                _state = initialState;
                _state.Validate();
            }
            base.Start();
            subscribeAutos();
        }

        #endregion

        #region Vector service handlers

        /// <summary>
        /// Callback giving you the opportunity to set the state before it is
        /// retrieved due to a request.  The requestInfo parameter will be
        /// either a GetElementRequestInfo class, or a GetAllRequestInfo class.
        /// Use the "is" keyword to find out which one (and thus what type the
        /// request was).  This class, once casted to the right type, contains
        /// information about the specific request.  See the Vector class
        /// description for more information.
        /// </summary>
        protected virtual IEnumerator<ITask> GetCallback(GetRequestInfo request, PortSet<CallbackResponseType, Fault> responsePort)
        {
            responsePort.Post(CallbackResponseType.Instance);
            yield break;
        }

        /// <summary>
        /// Callback giving you the opportunity to take action after the state
        /// is modified by a request.  The requestInfo parameter will be
        /// either a SetElementRequestInfo class, or a SetAllRequestInfo class.
        /// Use the "is" keyword to find out which one (and thus what type the
        /// request was).  This class, once casted to the right type, contains
        /// information about the specific request.  See the Vector class
        /// description for more information.
        /// </summary>
        protected virtual IEnumerator<ITask> SetCallback(SetRequestInfo request, PortSet<CallbackResponseType, Fault> responsePort)
        {
            responsePort.Post(CallbackResponseType.Instance);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> GetHandler(Get get)
        {
            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s) { get.ResponsePort.Post(_state); },
                delegate(Fault f) { get.ResponsePort.Post(f); }));

            return GetCallback(new GetAllRequestInfo(), responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> HttpGetHandler(HttpGet get)
        {
            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s) { get.ResponsePort.Post(new HttpResponseType(_state)); },
                delegate(Fault f) { get.ResponsePort.Post(f); }));

            return GetCallback(new GetAllRequestInfo(), responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> ReplaceHandler(Replace replace)
        {
            _state = replace.Body;
            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    replace.ResponsePort.Post(DefaultReplaceResponseType.Instance);
                    SendNotification<Replace>(replace);
                },
                delegate(Fault f) { replace.ResponsePort.Post(f); }));

            return SetCallback(new SetAllRequestInfo()
                {
                    Timestamp = replace.Body.Timestamp,
                    Values = replace.Body.Values
                },
                responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> GetByIndexHandler(GetByIndex get)
        {
            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    try
                    {
                        get.ResponsePort.Post(new GetElementResponseType()
                        {
                            Value = _state.Get(get.Body.Index),
                            Timestamp = _state.Timestamp
                        });
                    }
                    catch (Exception e)
                    {
                        get.ResponsePort.Post(RSUtils.FaultOfException(e));
                    }
                },
                delegate(Fault f) { get.ResponsePort.Post(f); }));

            return GetCallback(new GetElementRequestInfo()
                {
                    RequestType = RequestType.ByIndex,
                    Index = get.Body.Index,
                    Key = ((get.Body.Index < _state.Keys.Count) ? _state.Keys[get.Body.Index] : "")
                },
                responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> GetByKeyHandler(GetByKey get)
        {
            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    try
                    {
                        get.ResponsePort.Post(new GetElementResponseType()
                        {
                            Value = _state.Get(_state.indexCache[get.Body.Key]),
                            Timestamp = _state.Timestamp
                        });
                    }
                    catch (Exception e)
                    {
                        get.ResponsePort.Post(RSUtils.FaultOfException(e));
                    }
                },
                delegate(Fault f) { get.ResponsePort.Post(f); }));

            IEnumerator<ITask> tasks;
            try
            {
                return GetCallback(new GetElementRequestInfo()
                {
                    RequestType = RequestType.ByKey,
                    Index = _state.indexCache[get.Body.Key],
                    Key = get.Body.Key
                }, responsePort);
            }
            catch (Exception e)
            {
                get.ResponsePort.Post(RSUtils.FaultOfException(e));
                return RSUtils.EmptyEnumerator<ITask>();
            }
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> GetAllHandler(GetAllElements get)
        {
            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    get.ResponsePort.Post(new GetAllElementsResponseType()
                        {
                            Values = _state.Values,
                            Timestamp = _state.Timestamp
                        });
                },
                delegate(Fault f)
                { get.ResponsePort.Post(f); }));

            return GetCallback(new GetAllRequestInfo(), responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> SetByIndexHandler(SetByIndex set)
        {
            try
            {
                if (set.Body.Indices.Count != set.Body.Values.Count)
                    throw new ArgumentException("Lengths of indices and values lists must match");
                for (int i = 0; i < set.Body.Indices.Count; i++)
                    _state.Values[set.Body.Indices[i]] = set.Body.Values[i];
                _state.Timestamp = set.Body.Timestamp;
            }
            catch (Exception e)
            {
                set.ResponsePort.Post(RSUtils.FaultOfException(e));
                return RSUtils.EmptyEnumerator<ITask>();
            }

            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    set.ResponsePort.Post(DefaultUpdateResponseType.Instance);
                    SendNotification<SetByIndex>(set);
                },
                delegate(Fault f) { set.ResponsePort.Post(f); }));
            return SetCallback(new SetElementsRequestInfo()
            {
                RequestType = RequestType.ByIndex,
                Indices = set.Body.Indices,
                Keys = new List<string>(
                    from i in set.Body.Indices
                    select (i < _state.Keys.Count ? _state.Keys[i] : "")),
                Timestamp = set.Body.Timestamp,
                Values = set.Body.Values
            }, responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> SetByKeyHandler(SetByKey set)
        {
            List<int> indices;
            try
            {
                if (set.Body.Keys.Count != set.Body.Values.Count)
                    throw new ArgumentException("Lengths of indices and values lists must match");
                indices = new List<int>(set.Body.Keys.Count);
                for (int i = 0; i < set.Body.Keys.Count; i++)
                {
                    int index = _state.indexCache[set.Body.Keys[i]];
                    _state.Values[index] = set.Body.Values[i];
                    indices.Add(index);
                }
            }
            catch (Exception e)
            {
                set.ResponsePort.Post(RSUtils.FaultOfException(e));
                return RSUtils.EmptyEnumerator<ITask>();
            }

            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    set.ResponsePort.Post(DefaultUpdateResponseType.Instance);
                    SendNotification<SetByKey>(set);
                },
                delegate(Fault f) { set.ResponsePort.Post(f); }));
            return SetCallback(new SetElementsRequestInfo()
            {
                RequestType = RequestType.ByKey,
                Indices = indices,
                Keys = set.Body.Keys,
                Timestamp = set.Body.Timestamp,
                Values = set.Body.Values
            }, responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> SetAllHandler(SetAllElements setAll)
        {
            _state.SetAll(setAll.Body.Values, setAll.Body.Timestamp);

            var responsePort = new DsspResponsePort<CallbackResponseType>();
            Activate(Arbiter.Choice(responsePort,
                delegate(CallbackResponseType s)
                {
                    setAll.ResponsePort.Post(DefaultUpdateResponseType.Instance);
                    SendNotification<SetAllElements>(setAll);
                },
                delegate(Fault f) { setAll.ResponsePort.Post(f); }));
            return SetCallback(new SetAllRequestInfo()
            {
                Values = setAll.Body.Values,
                Timestamp = setAll.Body.Timestamp
            }, responsePort);
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> SubscribeHandler(Subscribe subscribe)
        {
            yield return Arbiter.Choice(
                SubscribeHelper(_subMgrPort, subscribe.Body, subscribe.ResponsePort),
                delegate(SuccessResult success)
                {
                    base.SendNotification<Replace>(_subMgrPort, subscribe.Body.Subscriber, _state);
                },
                delegate(Exception error)
                {
                    base.LogError("Error adding subscriber " + subscribe.Body.Subscriber, error);
                });
        }

        #endregion

        #region Private and protected methods
        protected void SendNotification<T>(T message) where T : DsspOperation
        {
            base.SendNotification<T>(_subMgrPort, message);
        }
        #endregion

        #region Auto subscription methods

        ///// <summary>
        ///// </summary>
        //private void subscribeAutos()
        //{
        //    // Get the list of partners whose names start with "auto:"
        //    //var request = new partnerList.GetOperation()
        //    //{
        //    //    Body = new GetRequestType(),
        //    //    ResponsePort = new DsspResponsePort<PartnerListType>()
        //    //};
        //    //base.PartnerListManagerPort.Post(request);
        //    //Activate(Arbiter.Choice<PartnerListType, Fault>(
        //    //    request.ResponsePort,
        //    //    delegate(PartnerListType partners)
        //    //    {
        //    //        string autoPrefix = "Auto_";
        //    //        List<PartnerType> autoPartners = new List<PartnerType>(
        //    //            from partner in partners.PartnerList
        //    //            where partner.Name.Name.StartsWith(autoPrefix)
        //    //            select partner);

        //    //        foreach (var p in autoPartners)
        //    //            Console.WriteLine(p.Name);

        //    //        // This method will take care of subscribing and updating state
        //    //        //if (autoPartners.Count > 0)
        //    //        //    subscribeAutos2(autoPartners, autoPrefix.Length);
        //    //    },
        //    //    delegate(Fault failure)
        //    //    {
        //    //        LogError("Fault while getting partner list to subscribe to autos", failure);
        //    //    }));

        //    //List<PartnerType> partnerList = new List<PartnerType>();
        //    //var responsePort = new DsspResponsePort<DefaultUpsertResponseType>();
        //    //Activate(Arbiter.MultipleItemReceive(responsePort, _state.AutoSubsets.Count,
        //    //    delegate(ICollection<DefaultUpsertResponseType> successes, ICollection<Fault> failures)
        //    //    {
        //    //        foreach (Fault failure in failures)
        //    //            LogError("Inserting partner failed", failure);
        //    subscribeAutos2();
        //    //}));
        //}

        /// <summary>
        /// Subscribes to any services specified in the partner list to
        /// automatically update the state.
        /// Once we have a list of auto partners, this method creates AutoDefiniton
        /// objects for each auto partner.  It then waits for each partner to be
        /// found, and calls subscribeAutoSingle to subscribe to each one.
        /// </summary>
        /// <param name="partList"></param>
        /// <param name="removeFromName"></param>
        private void subscribeAutos()
        {
            //foreach (var subset in _state.AutoSubsets)
            //{
            //    PartnerType partner = new PartnerType() { Name = new XmlQualifiedName(subset.PartnerName, Contract.Identifier) };
            //    partnerList.Add(partner);
            //    //base.PartnerListManagerPort.Post(new partnerList.Upsert() { Body = partner, ResponsePort = responsePort });
            //}
            // Create AutoDefinition objects
            autoDefs = new List<AutoDefinition>(_state.AutoSubsets.Count);
            //int lastIndex = 0;
            //List<string> allKeys = new List<string>();
            List<double> allValues = new List<double>();
            foreach (var subset in _state.AutoSubsets)
            {
                // Create AutoDefinition object and add to list
                //string[] keys = part.Name.Name.Substring(removeFromName).Split('_');
                //AutoSubset subset = _state.AutoSubsets.Find((s => part.Name.Name.Equals(s.PartnerName, StringComparison.OrdinalIgnoreCase)));
                //if (subset != default(AutoSubset))
                //{
                //var newKeys = new List<string>();
                //for (int i = 0; i < subset.startIndex; i++)
                //    newKeys.Add("");
                //newKeys.AddRange(subset.keys);
                //}
                AutoDefinition autoDef = new AutoDefinition()
                {
                    partnerName = subset.PartnerName,
                    startIndex = 0,
                    count = 0,
                    subsetStart = (subset == default(AutoSubset) ? 0 : subset.StartIndex),
                    subsetCount = (subset == default(AutoSubset) ? 0 : subset.Count),
                    keys = (subset == default(AutoSubset) ? new List<string>() : subset.Keys)
                };
                autoDefs.Add(autoDef);
            }

            foreach (var autoDef in autoDefs)
                if (autoDef.subsetCount >= 1)
                {
                    // Also build a default vector
                    var values = new List<double>(autoDef.subsetCount);
                    for (int i = 0; i < autoDef.subsetCount; i++)
                        values.Add(0.0);
                    modifyStateSubset(autoDef, values);
                }


            // Set values, and take keys provided in subset defs by user
            //_state.SetAll(allValues, DateTime.Now);
            //applyKeysFromSubsets();

            //var upsertRespPort = new DsspResponsePort<DefaultUpsertResponseType>();
            //PartnerListManagerPort.Post(new partnerList.Upsert() { Body = new PartnerType() { Name = new XmlQualifiedName("iRobotGenericDrive", Microsoft.Dss.ServiceModel.Dssp.Contract.Identifier) }, ResponsePort = upsertRespPort });
            //Activate(Arbiter.Choice(upsertRespPort,
            //    delegate(DefaultUpsertResponseType suc)
            //    {
            //        //var queryRespPort = new DsspResponsePort<Microsoft.Dss.Schemas.PartnerListManager.QueryResponseType>();
            //        //PartnerListManagerPort.Post(new partnerList.Query() { Body = new partnerListS.QueryRequestType() { Name = new XmlQualifiedName("iRobotGenericDrive", Contract.Identifier) }, ResponsePort = queryRespPort });
            //        //Activate(Arbiter.Choice(queryRespPort,
            //        //    delegate(partnerListS.QueryResponseType qsuc)
            //        //    {
            //        //        Console.WriteLine(qsuc.Partner.Name + " : " + qsuc.Partner.Contract + " : " + qsuc.Partner.Service);
            //        //    },
            //        //    delegate(Fault failure)
            //        //    {
            //        //        Console.WriteLine("Fault querying");
            //        //    }));
            //        var partsRespPort = base.IssuePartnerSubscribe(new XmlQualifiedName("iRobotGenericDrive", Microsoft.Dss.ServiceModel.Dssp.Contract.Identifier));
            //        Activate(Arbiter.Choice(partsRespPort,
            //            delegate(PartnerListType partListResponse)
            //            {
            //                foreach (var partner in partListResponse.PartnerList)
            //                {
            //                    Console.WriteLine(partner.Name + " : " + partner.Contract + " : " + partner.Service);
            //                }
            //            },
            //            delegate(Fault failure)
            //            {
            //                Console.WriteLine("Fault querying");
            //            }));
            //    },
            //    delegate(Fault fail)
            //    {
            //        Console.WriteLine("Fault upserting");
            //    }));


            // Create the new vector state reflecting the keys
            //List<double> allValues = new List<double>(from k in allKeys select 0.0);
            //VectorState newState = new VectorState(allValues, allKeys, DateTime.Now);
            //var responsePort = new DsspResponsePort<DefaultReplaceResponseType>();
            //OperationsPort.Post(new Replace(newState, responsePort));
            //Activate(Arbiter.Choice(responsePort,
            //    delegate(DefaultReplaceResponseType r) { },
            //    delegate(Fault f) { LogError("Fault while replacing initial vector state", f); }));

            // Try to subscribe to compatible contracts with the AutoDefinition objects
            foreach (var autoDef in autoDefs)
            {
                AutoDefinition myAutoDef = autoDef;
                //Console.WriteLine("Waiting 10 seconds before subscribing to partner list...");
                //Thread.Sleep(10000);
                var partRespPort = base.IssuePartnerSubscribe(new XmlQualifiedName(myAutoDef.partnerName, Contract.Identifier));
                //Console.WriteLine("Looking for " + myAutoDef.infoAsPartner.Name);
                Activate(Arbiter.Choice(partRespPort,
                    delegate(PartnerListType partListResponse)
                    {
                        //Console.WriteLine("Found " + partListResponse.PartnerList.Count + " for " + myAutoDef.infoAsPartner.Name);
                        if (partListResponse.PartnerList.Count > 1)
                            LogWarning("More than one partner found for " + myAutoDef.partnerName);
                        else if (partListResponse.PartnerList.Count < 1)
                            LogWarning("No partners found for " + myAutoDef.partnerName);
                        foreach (var partner in partListResponse.PartnerList)
                        {
                            if (myAutoDef.infoAsConnected == null)
                            {
                                //Console.WriteLine("Searching for a contract for " + partner.Service);
                                Activate(Arbiter.Choice(RSUtils.FindCompatibleContract(TaskQueue, new Uri(partner.Service), new List<string>() { 
                                            analog.Contract.Identifier, analogArray.Contract.Identifier, contact.Contract.Identifier }),
                                    delegate(ServiceInfoType serviceInfoResponse)
                                    {
                                        try
                                        {
                                            subscribeAutoSingle(myAutoDef, serviceInfoResponse);
                                            myAutoDef.infoAsConnected = serviceInfoResponse;
                                            LogInfo("Vector service " + base.ServiceInfo.Service + " subscribed auto update to " + serviceInfoResponse.Service + " with contract " + serviceInfoResponse.Contract);
                                        }
                                        catch (Exception e)
                                        {
                                            LogError("Exception while subscribing to auto partner", e);
                                        }
                                    },
                                    delegate(Fault failure)
                                    {
                                        Exception e = RSUtils.ExceptionOfFault(failure);
                                        if (e is NoContractFoundException)
                                        {
                                            LogError("Could not subscribe to auto partner " + myAutoDef.partnerName + ".  Could not find a supported contract.");
                                        }
                                        else if (e is Exception)
                                        {
                                            LogError("Fault while searching for compatible contract", e);
                                        }
                                    }));
                            }
                        }
                    },
                    delegate(Fault failure)
                    {
                        Console.WriteLine("Fault for " + myAutoDef.partnerName);
                        LogError("Fault from subscription to partner list service", failure);
                    }));
                //Thread.Sleep(2000);
            }
        }

        /// <summary>
        /// Tries to subscribe to an auto partner single contract, or throws an exception
        /// if we don't support the contract.  Also starts a 1-second poll that continues
        /// until publishers send non-zero-length arrays.
        /// </summary>
        /// <param name="def"></param>
        /// <param name="serviceInfo"></param>
        private void subscribeAutoSingle(AutoDefinition def, ServiceInfoType serviceInfo)
        {
            // Check for each contract we know about and subscribe.

            ////////////////// Analog Sensor
            if (serviceInfo.Contract.Equals(analog.Contract.Identifier))
            {
                var partnerPort = ServiceForwarder<analog.AnalogSensorOperations>(new Uri(serviceInfo.Service));
                var notifyPort = new Port<analog.Replace>();
                Activate(Arbiter.Choice(partnerPort.Subscribe(notifyPort, typeof(analog.Replace)),
                    delegate(SubscribeResponseType success)
                    {
                        MainPortInterleave.CombineWith(new Interleave(
                            new ExclusiveReceiverGroup(
                                Arbiter.Receive(true, notifyPort,
                                    delegate(analog.Replace replace)
                                    { autoSubscribeNotificationHelper(def, new List<double>(1) { replace.Body.RawMeasurement }, replace.Body.TimeStamp, false); }
                                )),
                            new ConcurrentReceiverGroup()));
                    },
                    delegate(Fault failure)
                    {
                        LogError("Fault while subscribing to auto partner", failure);
                    }));
            }

            ////////////////// Analog Sensor Array
            else if (serviceInfo.Contract.Equals(analogArray.Contract.Identifier))
            {
                var partnerPort = ServiceForwarder<analogArray.AnalogSensorOperations>(new Uri(serviceInfo.Service));
                var notifyPort = new Port<analogArray.Replace>();
                var pollPort = base.TimeoutPort(1000);
                bool gotNonzeroState = false;
                Activate(Arbiter.Receive(true, pollPort,
                    delegate(DateTime time)
                    {
                        if (gotNonzeroState == false)
                        {
                            Activate(Arbiter.Choice(partnerPort.Get(),
                                delegate(analogArray.AnalogSensorArrayState state) { notifyPort.Post(new analogArray.Replace(state)); },
                                delegate(Fault failure) { LogError("Vector got fault while trying to get polled state", failure); }));
                            TaskQueue.EnqueueTimer(TimeSpan.FromMilliseconds(1000.0), pollPort);
                        }
                    }));
                Activate(Arbiter.Choice(partnerPort.Subscribe(notifyPort, typeof(analogArray.Replace)),
                    delegate(SubscribeResponseType success)
                    {
                        MainPortInterleave.CombineWith(new Interleave(
                            new ExclusiveReceiverGroup(
                                Arbiter.Receive(true, notifyPort,
                                    delegate(analogArray.Replace replace)
                                    {
                                        if (replace.Body.Sensors.Count > 0)
                                            gotNonzeroState = true;
                                        autoSubscribeNotificationHelper(def,
                                            new List<double>(from s in replace.Body.Sensors select s.RawMeasurement),
                                            (replace.Body.Sensors.Count > 0 ? replace.Body.Sensors[0].TimeStamp : DateTime.Now), false);
                                    })),
                            new ConcurrentReceiverGroup()));
                    },
                    delegate(Fault failure)
                    {
                        LogError("Fault while subscribing to auto partner", failure);
                    }));
            }

            ////////////////// Contact Sensor
            else if (serviceInfo.Contract.Equals(contact.Contract.Identifier))
            {
                var partnerPort = ServiceForwarder<contact.ContactSensorArrayOperations>(new Uri(serviceInfo.Service));
                var notifyPort = new PortSet<contact.Replace, contact.Update>();
                // Post an initial Replace notification to update the HW ID map (no, this is now done automatically)
                //notifyPort.Post(new contact.Replace(RSUtils.ReceiveSync(TaskQueue, partnerPort.Get(), Params.defaultRecieveTimeout)));
                var pollPort = base.TimeoutPort(1000);
                bool gotNonzeroState = false;
                Activate(Arbiter.Receive(true, pollPort,
                    delegate(DateTime time)
                    {
                        if (gotNonzeroState == false)
                        {
                            Activate(Arbiter.Choice(partnerPort.Get(),
                                delegate(contact.ContactSensorArrayState state) { notifyPort.Post(new contact.Replace(state)); },
                                delegate(Fault failure) { LogError("Vector got fault while trying to get polled state", failure); }));
                            TaskQueue.EnqueueTimer(TimeSpan.FromMilliseconds(1000.0), pollPort);
                        }
                    }));
                Activate(Arbiter.Choice(partnerPort.Subscribe(notifyPort, typeof(contact.Replace), typeof(contact.Update)),
                    delegate(SubscribeResponseType success)
                    {
                        var contactHWIDMap = new Dictionary<int, int>();
                        MainPortInterleave.CombineWith(new Interleave(
                            new ExclusiveReceiverGroup(
                                Arbiter.Receive<contact.Replace>(true, notifyPort,
                                    delegate(contact.Replace replace)
                                    {
                                        if (replace.Body.Sensors.Count > 0)
                                            gotNonzeroState = true;
                                        if (def.hwKeys.Count < replace.Body.Sensors.Count)
                                        {
                                            def.hwKeys.Capacity = replace.Body.Sensors.Count;
                                            while (def.hwKeys.Count < replace.Body.Sensors.Count) def.hwKeys.Add("");
                                        }
                                        // Refresh the HW ID map
                                        contactHWIDMap.Clear();
                                        for (int i = 0; i < replace.Body.Sensors.Count; i++)
                                        {
                                            contactHWIDMap.Add(replace.Body.Sensors[i].HardwareIdentifier, i);
                                            //if (def.hwKeys[i] == null || def.hwKeys[i].Length <= 0)
                                            def.hwKeys[i] = replace.Body.Sensors[i].Name;
                                        }
                                        autoSubscribeNotificationHelper(def,
                                            new List<double>(from s in replace.Body.Sensors select (s.Pressed ? 1.0 : 0.0)),
                                            (replace.Body.Sensors.Count > 0 ? replace.Body.Sensors[0].TimeStamp : DateTime.Now), true);
                                    }),
                                Arbiter.Receive<contact.Update>(true, notifyPort,
                                    delegate(contact.Update update)
                                    {
                                        gotNonzeroState = true;
                                        try
                                        {
                                            int i = contactHWIDMap[update.Body.HardwareIdentifier];
                                            autoSubscribeNotificationUpdateHelper(def, i, (update.Body.Pressed ? 1.0 : 0.0), update.Body.TimeStamp);
                                        }
                                        catch (KeyNotFoundException)
                                        {
                                            LogError("Vector got update for contact sensor hardware identifier " + update.Body.HardwareIdentifier + " and doesn't know about this hardware ID.  Trying to fetch entire state.");
                                            Activate(Arbiter.Choice(partnerPort.Get(),
                                                delegate(contact.ContactSensorArrayState state) { notifyPort.Post(new contact.Replace(state)); },
                                                delegate(Fault failure) { LogError("Vector got fault while trying to get contact state", failure); }));
                                        }
                                    })),
                            new ConcurrentReceiverGroup()));
                    },
                    delegate(Fault failure)
                    {
                        LogError("Fault while subscribing to auto partner", failure);
                    }));
            }
            else
                throw new UnrecognizedContractException();
        }

        /// <summary>
        /// Helper for notification handlers.  This relies on being called from
        /// an "exclusive" handler - it modifies the state directly!
        /// </summary>
        /// <param name="autoDef"></param>
        /// <param name="values"></param>
        /// <param name="timestamp"></param>
        private void autoSubscribeNotificationHelper(AutoDefinition autoDef, List<Double> values, DateTime timestamp, bool keysChanged)
        {
            int useableValueCount =
                ((autoDef.subsetStart + (autoDef.subsetCount >= 1 ? autoDef.subsetCount : Int32.MaxValue)) <= values.Count) ?
                autoDef.subsetCount :
                (values.Count - autoDef.subsetStart);
            if (useableValueCount < 0)
                useableValueCount = 0;
            int vectorPartCount =
                (autoDef.subsetCount >= 1) ?
                autoDef.subsetCount :
                useableValueCount;
            //Console.WriteLine("Vector: for " + autoDef.infoAsPartner.Name.Name + " got " + values.Count + " values with " + useableCount + " useable");

            _state.Timestamp = timestamp;

            // If the number of values has changed, we need to rearrange the vector
            if (modifyStateSubset(autoDef, values))
            {
                _state.Validate();

                // Reapply keys
                applyKeysFromSubsets();

                // Send replace notification, a lot changed
                LogInfo("Vector length changed");
                SendNotification(new Replace(_state));
            }
            else
            {
                if (keysChanged)
                    applyKeysFromSubsets();

                // Send notification
                var indices = new List<int>(autoDef.count);
                for (int i = autoDef.startIndex; i < autoDef.startIndex + autoDef.count; i++)
                    indices.Add(i);
                SendNotification(new SetByIndex(new SetByIndexRequestType()
                {
                    Indices = indices,
                    Values = _state.Values.GetRange(autoDef.startIndex, autoDef.count),
                    Timestamp = timestamp
                }));
            }
        }

        private bool modifyStateSubset(AutoDefinition autoDef, List<Double> values)
        {
            // Figure out how many values we are actually using from this
            // publisher, based on the subset specification for this
            // subscription
            int useableValueCount =
                ((autoDef.subsetStart + (autoDef.subsetCount >= 1 ? autoDef.subsetCount : Int32.MaxValue)) <= values.Count) ?
                autoDef.subsetCount :
                (values.Count - autoDef.subsetStart);
            if (useableValueCount < 0)
                useableValueCount = 0;
            int vectorPartCount =
                (autoDef.subsetCount >= 1) ?
                autoDef.subsetCount :
                useableValueCount;

            if (vectorPartCount != autoDef.count)
            {
                // Shift Vector elements (not calling SetAll because we'll call SetKeys later to rebuild index cache)
                var newValues = new List<double>(_state.Values.Count + vectorPartCount - autoDef.count);
                newValues.AddRange(_state.Values.GetRange(0, autoDef.startIndex));
                if (useableValueCount > 0)
                    newValues.AddRange(values.GetRange(autoDef.subsetStart, useableValueCount));
                for (int i = useableValueCount; i < vectorPartCount; i++)
                    newValues.Add(0.0);
                newValues.AddRange(_state.Values.GetRange(autoDef.startIndex + autoDef.count, _state.Values.Count - (autoDef.startIndex + autoDef.count)));
                if (newValues.Count != (_state.Values.Count + vectorPartCount - autoDef.count))
                    LogError("Vector length consistency check No. 1 failed!!!");
                _state.Values = newValues;

                // Update AutoDefinitions startIndex's
                int firstChangedDef = autoDefs.IndexOf(autoDef) + 1;
                autoDef.count = vectorPartCount;
                int lastIndex = autoDef.startIndex + vectorPartCount;
                for (int i = firstChangedDef; i < autoDefs.Count; i++)
                {
                    autoDefs[i].startIndex = lastIndex;
                    lastIndex += autoDefs[i].count;
                }

                // Consistency check
                if (lastIndex != _state.Values.Count)
                    LogError("Vector length consistency check No. 2 failed!!!");

                return true;
            }
            else
            {
                // Just modify the affected elements
                for (int i = 0; i < useableValueCount; i++)
                    _state.Values[autoDef.startIndex + i] = values[autoDef.subsetStart + i];

                return false;
            }
        }

        private void applyKeysFromSubsets()
        {
            // Reapply keys
            var newKeys = new List<string>(_state.Values.Count);
            foreach (var def in autoDefs)
                for (int i = 0; i < def.count; i++)
                {
                    int defIndex = i + def.subsetStart;
                    // Try to get a key, first from user, then from hardware, if nothing else just blank
                    if (i < def.keys.Count)
                        newKeys.Add(def.keys[i]);
                    else if (defIndex < def.hwKeys.Count)
                        newKeys.Add(def.hwKeys[defIndex]);
                    else
                        newKeys.Add("");
                }
            _state.SetKeys(newKeys);
            if (newKeys.Count != _state.Values.Count)
                LogError("Key length != vector length!!!");
        }

        /// <summary>
        /// Helper for notification handlers.  This relies on being called from
        /// an "exclusive" handler - it modifies the state directly!
        /// </summary>
        /// <param name="autoDef"></param>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <param name="timestamp"></param>
        private void autoSubscribeNotificationUpdateHelper(AutoDefinition autoDef, int index, double value, DateTime timestamp)
        {
            if ((index - autoDef.subsetStart) < autoDef.count && index >= autoDef.subsetStart)
            {
                _state.Set(index - autoDef.subsetStart + autoDef.startIndex, value, timestamp);
                //Console.WriteLine("Updating " + index + " with start " + autoDef.startIndex + " and subset start " + autoDef.subsetStart + ".  State index " + (index - autoDef.subsetStart + autoDef.startIndex));
            }
            SendNotification(new SetByIndex(new SetByIndexRequestType() { Indices = new List<int>() { autoDef.startIndex + index }, Values = new List<double>() { value }, Timestamp = timestamp }));
        }

        class UnrecognizedContractException : Exception { }
        class AutoDefinition
        {
            public string partnerName;
            public int startIndex;
            public int count;
            public int subsetStart;
            public int subsetCount;
            public List<string> keys = new List<string>();
            public List<string> hwKeys = new List<string>();

            public ServiceInfoType infoAsConnected = null;
        }
        #endregion

    }

    #region Callback request info types
    /// <summary>
    /// For the RequestType member of GetElementRequestInfo and
    /// SetElementRequestInfo, this indicates whether the service request was
    /// (Get/Set)ByIndex, or (Get/Set)ByKey.
    /// </summary>
    public enum RequestType { ByIndex, ByKey }

    /// <summary>
    /// The abstract base class for GetElementRequestInfo and GetAllRequestInfo
    /// </summary>
    public abstract class GetRequestInfo
    {
    }

    /// <summary>
    /// Passed into GetCallback, provides information about the actual service
    /// request, if the request was either GetByIndex and GetByKey.  The
    /// RequestType property indicates whether the request was GetByIndex or
    /// GetByKey.
    /// </summary>
    public class GetElementRequestInfo : GetRequestInfo
    {
        public RequestType RequestType { get; set; }
        public int Index { get; set; }
        public string Key { get; set; }
    }

    /// <summary>
    /// Passed into GetCallback, if the request was GetState.  This does not
    /// contain any members, but only indicates that the service request was
    /// GetState.
    /// </summary>
    public class GetAllRequestInfo : GetRequestInfo
    {
    }

    /// <summary>
    /// The abstract base class for SetElementRequestInfo and SetAllRequestInfo
    /// </summary>
    public abstract class SetRequestInfo
    {
        public DateTime Timestamp { get; set; }
    }

    /// <summary>
    /// Passed into SetCallback, provides information about the actual service
    /// request, if the request was either SetByIndex and SetByKey.  The
    /// RequestType property indicates whether the request was SetByIndex or
    /// SetByKey.
    /// </summary>
    public class SetElementsRequestInfo : SetRequestInfo
    {
        public RequestType RequestType { get; set; }
        public List<int> Indices { get; set; }
        public List<string> Keys { get; set; }
        public List<double> Values { get; set; }
    }

    /// <summary>
    /// Passed into SetCallback, if the request was SetAll.  This contains the
    /// values that were set in the state.
    /// </summary>
    public class SetAllRequestInfo : SetRequestInfo
    {
        public List<double> Values { get; set; }
    }
    #endregion


}
