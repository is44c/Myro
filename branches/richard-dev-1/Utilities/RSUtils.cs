using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Dss.Core;
using Microsoft.Dss.Hosting;
using Microsoft.Dss.ServiceModel.Dssp;
using W3C.Soap;
using Microsoft.Ccr.Core;
using System.Threading;

namespace Myro.Utilities
{
    public static class RSUtils
    {
        /// <summary>
        /// Synchronous receive.
        /// Waits for a response, returning T on success, and throwing an
        /// exception created by ExceptionOfFault on failure.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="port"></param>
        /// <returns></returns>
        public static T RecieveSync<T>(DispatcherQueue taskQueue, PortSet<T, Fault> port)
        {
            T ret = default(T);
            Fault error = null;

            ManualResetEvent signal = new ManualResetEvent(false);
            Arbiter.Activate(taskQueue,
                Arbiter.Choice<T, Fault>(
                    port,
                    delegate(T state)
                    {
                        ret = state;
                        signal.Set();
                    },
                    delegate(Fault failure)
                    {
                        error = failure;
                        signal.Set();
                    }));
            signal.WaitOne();

            ThrowIfFaultNotNull(error);
            return ret;
        }

        /// <summary>
        /// Synchronous receive, using DssEnvironment.TaskQueue.
        /// Waits for a response, returning T on success, and throwing an
        /// exception created by ExceptionOfFault on failure.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="port"></param>
        /// <returns></returns>
        public static T RecieveSync<T>(PortSet<T, Fault> port)
        {
            return RecieveSync(DssEnvironment.TaskQueue, port);
        }


        /// <summary>
        /// If fault is not null, throws an exception generated by
        /// ExceptionOfFault.
        /// </summary>
        /// <param name="fault"></param>
        public static void ThrowIfFaultNotNull(Fault fault)
        {
            if (fault != null)
                throw ExceptionOfFault(fault);
        }

        /// <summary>
        /// Generates an exception from a Fault.  If the Fault encapsulates an
        /// exception (Fault.Detail.Any[0] is Exception), as do Faults created
        /// by FaultOfException, this method returns the exception.  Otherwise,
        /// it returns a FaultReceivedException, which encapsulates the Fault.
        /// </summary>
        /// <param name="fault"></param>
        /// <returns></returns>
        public static Exception ExceptionOfFault(Fault fault)
        {
            if (fault.Detail != null && fault.Detail.Any != null &&
                    fault.Detail.Any.Length > 0 && (fault.Detail.Any[0] is Exception))
                return (Exception)fault.Detail.Any[0];
            else
                return new FaultReceivedException(fault);
        }

        /// <summary>
        /// Generates a Fault that encapsulates an exception, by making
        /// Fault.Detail.Any[0] = exception.  The original exception can by
        /// retreived by calling ExceptionOfFault.
        /// </summary>
        /// <param name="exception"></param>
        /// <returns></returns>
        public static Fault FaultOfException(Exception exception)
        {
            return new Fault() { Detail = new Detail() { Any = new object[] { exception } } };
        }

        /// <summary>
        /// This method searches for a primary or alternate contract of the
        /// service that is present in the contracts list.  Requires a 
        /// taskQueue to activate tasks on.  Throws NoContractFoundException
        /// if one cannot be found.
        /// </summary>
        /// <param name="taskQueue"></param>
        /// <param name="service"></param>
        /// <param name="contracts"></param>
        /// <returns></returns>
        public static PortSet<ServiceInfoType, Fault> FindCompatibleContract(DispatcherQueue taskQueue, Uri service, IList<string> contracts)
        {
            PortSet<ServiceInfoType, Fault> returnPort = new PortSet<ServiceInfoType, Fault>();

            PortSet<LookupResponse, Fault> responsePort = new PortSet<LookupResponse, Fault>();
            DssEnvironment.ServiceForwarderUnknownType(service).PostUnknownType(
                new DsspDefaultLookup() { Body = new LookupRequestType(), ResponsePort = responsePort });
            Arbiter.Activate(taskQueue, Arbiter.Choice<LookupResponse, Fault>(
                responsePort,
                delegate(LookupResponse resp)
                {
                    ServiceInfoType ret = null;
                    int retIndex = Int32.MaxValue;

                    // See if we can understand the primary contract
                    try
                    {
                        int i = contracts.IndexOf(
                            contracts.First(
                                (s => resp.Contract.Equals(s, StringComparison.OrdinalIgnoreCase))
                            ));
                        if (i < retIndex)
                        {
                            ret = resp;
                            retIndex = i;
                        }
                    }
                    catch (InvalidOperationException) { }

                    // Now try each alternate contract
                    foreach (var part in resp.PartnerList)
                        // Alternate contract services have a name of "AlternateContractService".
                        if (part.Name.Name.StartsWith("AlternateContractService"))
                            try
                            {
                                int i = contracts.IndexOf(contracts.First((s => part.Contract.Equals(s, StringComparison.OrdinalIgnoreCase))));
                                if (i < retIndex)
                                {
                                    ret = part;
                                    retIndex = i;
                                }
                            }
                            catch (InvalidOperationException) { }

                    if (ret != null)
                        returnPort.Post(ret);
                    else
                        returnPort.Post(FaultOfException(new NoContractFoundException()));
                },
                delegate(Fault failure)
                {
                    returnPort.Post(failure);
                }));

            return returnPort;
        }
    }

    /// <summary>
    /// An exception that encapsulates a fault, which is thrown if a fault is
    /// generated that itself does not encapsulate an exception (such as a 
    /// fault generated by the DSS system).  If a Fault does encapsulate an
    /// exception, that exception is thrown instead (using ExceptionOfFault()).
    /// </summary>
    public class FaultReceivedException : Exception
    {
        public Fault Fault { get; private set; }
        public FaultReceivedException(Fault fault)
        {
            Fault = fault;
        }
        public override string ToString()
        {
            return Strings.FromFault(Fault);
        }
    }

    /// <summary>
    /// This is thrown by FindCompatibleContract when a compatible contract
    /// cannot be found.
    /// </summary>
    public class NoContractFoundException : Exception { }
}
